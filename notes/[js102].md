# 什麼是 NPM ?
npm（全稱 Node Package Manager，即「node包管理器」）是Node.js預設的、用JavaScript編寫的軟體套件管理系統。

## 功能說明
+ npm模組倉庫提供了一個名為「registry」的查詢服務，用戶可通過原生的npm命令下載並安裝指定模組。
+ 用戶也可以通過npm把自己設計的模組分發到registry上面。
+ 註：npm會隨著Node.js自動安裝。

## NPM 常用指令
+ `npm -v`：觀看 NPM 版本
+ `npm init`：新增 package.json
+ `npm install [模組名稱]`：安裝 NPM 模組
	+ `npm install [模組名稱] -g`：全域安裝
+ `npm list`：顯示安裝的 NPM 列表
+ `npm uninstall [模組名稱]`：刪除專案裡的 NPM

## `npm install` 的妙用
通常 node_modules 資料夾不會被加入版本控制裡面 (.gitignore)，所以可用 `npm install` 指令將裡面的模組一一安裝回來。
+ 又或者 node_modules 資料夾被刪除或遺失的時候。
+ 註：最一開始須先使用 `npm init` 新增一個 package.json 檔案。
---
## NPM scripts
``` json
//in package.json
{
  "name": "fortesting",
  "version": "1.0.0",
  "description": "",
  "main": "JSpractice.js",
  "scripts": {
    "start": "node JSpractice",
    "tryEcho": "echo 123",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "left-pad": "^1.3.0"
  }
}
```
+ 每次要執行 JSpractice 這個檔案的時候，都是從終端機輸入：`node JSpractice` 指令，而透過 NPM scripts 可以自己設計腳本來使用。
+ 用法：
	+ 使用 npm run [script name] 指令。
	+ 這邊的範例是使用　`npm run start` 來達成跟 `node JSpractice` 一樣的效果。
	+ 範例二：使用　`npm run tryEcho` 等於在終端機輸入 `echo 123`。
---
## NPM 版本號
打開 package.json 裡面的內容如下：
``` 
//...
"dendencies": {
   "accepts": "~1.3.7",
   "array-flatten": "1.1.1",
   "body-parser": "^1.19.0",
   // ...
 }
```
以 `"accepts": "~1.3.7",` 這行為例：
+ 1 代表主要版本號
+ 3 代表次要版本號
+ 7 代表修訂號 (bug)
+ `~` 波浪符號代表指定安裝為不超過**次要**版本號的版本 (指定為 >= 1.3.7 且 < 1.4.0 的版本)

以 `"body-parser": "^1.19.0",` 這行為例：
+ 1 代表主要版本號
+ 19 代表次要版本號
+ 0 代表修訂號 (bug)
+ `^` 符號代表指定安裝為不超過**主要**版本號的版本 (指定為 >= 1.19.0 且 < 2.0.0 的版本)

> 參考資料：[npm 維基百科](https://zh.wikipedia.org/wiki/Npm) & [NPM是什麼？了解Node Package Manager套件管理機制](https://tw.alphacamp.co/blog/npm-node-package-manager)

# 模組化與 Library
## 引用別人的模組
``` js
var module =require('os')
console.log(module.platform()) //win32
```

+ `require` 為引入的指令
+ `os` 為 Node.js 提供的 module

## 自己寫模組來用
### Step 1. 建立一個 JS 檔案 (這邊命名為 myModule.js)
``` js
//in myModule.js

function double(x) {
  return x * 2
}

module.exports = {
    double: double,
    triple: function(x){
        return x * 3
    }
}
```
### Step 2. 再建立一個 JS 檔案 (主要 JS 檔案，這邊命名為 main.js)
``` js
//in main.js

var myModule = require('./myModule.js')
console.log(myModule)
=> { double: [Function: double], triple: [Function: triple] }

console.log(myModule.double(2)) // output to be 4
console.log(myModule.triple(3)) // output to be 9
```
+ `var myModule = require('./myModule.js')`：引入的模組非 Node.js 提供或從 NPM 下載安裝，所以要自己輸入檔案路徑。
+ `module.exports`：輸出 module 的指令。

## 延伸題：另一種輸出指令 (exports.[keyName])
``` js
//in myModule.js
let arr1 = [1, 2, 3]

exports.arr1 = arr1
exports.arr2 = [4, 5, 6]

-------

//in main.js
var myModule = require('./myModule')
console.log(myModule) // output to be => { arr1: [ 1, 2, 3 ], arr2: [ 4, 5, 6 ] } 物件型態
```
+ `exports.[keyName]` 指令只能輸出成物件
+ `module.exports` 指令可輸出成字串或者陣列等其他型態 (雖然陣列也是物件的一種)，範例如下：

``` js
//in myModule.js
let arr1 = [1, 2, 3]
module.exports = arr1


-------

//in main.js
var myModule = require('./myModule')
console.log(myModule) // output to be => [1, 2, 3] 陣列型態
```
# ES6 (ES 2015)
## 新的宣告變數方式 const 與 let
+ ### const (constant variable)：宣告一個常數，其值不能再被變動
``` js
const PI = 3.14
PI = 20
console.log(a) // output to be => TypeError: Assignment to constant variable.
```
注意！以下情況例外：
``` js
const obj = {
  b: 10
}

obj.b = 20
console.log(b) // output to be 20

---

const arr = [1, 2, 3]
arr.push(4, 5)
console.log(arr) // output to be [1, 2, 3, 4, 5]
```
因為變數存取物件(陣列)的方式是存取記憶體位置，原則上此 obj 物件的記憶體位置(指引)沒有被更動，被更動的是指引指向的值。
這是一個比較抽象的概念，可以回顧一下這兩篇 [從 Object 的等號真正的理解變數](https://github.com/TsaiChihWei/learning-blog/issues/4)與[從博物館寄物櫃理解變數儲存模型](https://medium.com/@hulitw/variable-and-frontdesk-a53a0440af3c)。

---
## 作用域 scope (變數的生存範圍)
+ ### let 與 const 是區塊作用域 (block scope) `{} 包起來的區域`
+ ### var 是函式作用域 (function scope)
``` js
function test() {
    if (true) {
        var a = 10
    } 
    console.log(a);
}

test() // output to be 10
```
使用 `var` 宣告變數 a 時，可用範圍在 test function 內，即便 `console.log(a)` 在 if block 之外仍能讀取到 a 的值。
``` js
function test() {
    if (true) {
        let a = 10
    } 
    console.log(a)
}

test() // ReferenceError: a is not defined
```
使用 `let` 宣告變數 a 時，可用範圍在 if block (大括號) 內，所以 `console.log(a)` 在離開 if block 的區域便無法讀取到 a 的值。
``` js
function test() {
    if (true) {
        const a = 10
    } 
    console.log(a)
}

test() // ReferenceError: a is not defined
```
`const` 與 `let` 同理，都是區塊作用域 (block scope)。
### 因應 ES6 的出現，使用上建議不要再用 `var` 來宣告變數，改用 `let` 與 `const`，限縮變數的活動範圍來減少發生錯誤的可能。

## 模板字串 Template Literals
+ Template Literals 是增強版的字串表示法，Template Literals 讓你可以寫多行字串 (multi-line strings)、也可以在字串中插入變數或 JavaScript 表達式。
+ 用法：使用兩個反引號 (back-tick) ` ` 標示，而在字串中可以使用 `${ }` 語法來嵌入變數或 JavaScript 表達式。
### 多行字串 Multi-line Strings
``` js
//傳統寫法
let str = 'this is line one\n' + 'this is line two'
console.log(str); /* output to be =>

this is line one
this is line two 
*/
// 反斜線n \n 為換行


//Template Literals 寫法
let newStr = `
this is line one
this is line two`
console.log(newStr) /* output to be =>

this is line one
this is line two 
*/
```
### 嵌入變數或任何表達式
``` js
//傳統寫法
let name1 = 'Jack'
let age1 = 25
console.log('His name is ' + name1 + 'and he is ' + age1 + ' years old.')
// output to be => His name is Jack and he is 25 years old.


//Template Literals 寫法
let name2 = 'Ryan'
let age2 = 23
console.log(`His name is ${name2} and he is ${age2} years old.`)
// output to be => His name is Ryan and he is 23 years old.


//加入表達式
//${} 中可以是任何 JavaScript expression
function sayHello(name) {
    return `Hello ${name.toUpperCase()}!`
}
console.log(sayHello('Maggie')) //output to be => Hello MAGGIE!
```