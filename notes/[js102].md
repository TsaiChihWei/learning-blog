# 什麼是 NPM ?
npm（全稱 Node Package Manager，即「node包管理器」）是Node.js預設的、用JavaScript編寫的軟體套件管理系統。

## 功能說明
+ npm模組倉庫提供了一個名為「registry」的查詢服務，用戶可通過原生的npm命令下載並安裝指定模組。
+ 用戶也可以通過npm把自己設計的模組分發到registry上面。
+ 註：npm會隨著Node.js自動安裝。

## NPM 常用指令
+ `npm -v`：觀看 NPM 版本
+ `npm init`：新增 package.json
+ `npm install [模組名稱]`：安裝 NPM 模組
	+ `npm install [模組名稱] -g`：全域安裝
+ `npm list`：顯示安裝的 NPM 列表
+ `npm uninstall [模組名稱]`：刪除專案裡的 NPM

## `npm install` 的妙用
通常 node_modules 資料夾不會被加入版本控制裡面 (.gitignore)，所以可用 `npm install` 指令將裡面的模組一一安裝回來。
+ 又或者 node_modules 資料夾被刪除或遺失的時候。
+ 註：最一開始須先使用 `npm init` 新增一個 package.json 檔案。
---
## NPM scripts
``` json
//in package.json
{
  "name": "fortesting",
  "version": "1.0.0",
  "description": "",
  "main": "JSpractice.js",
  "scripts": {
    "start": "node JSpractice",
    "tryEcho": "echo 123",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "left-pad": "^1.3.0"
  }
}
```
+ 每次要執行 JSpractice 這個檔案的時候，都是從終端機輸入：`node JSpractice` 指令，而透過 NPM scripts 可以自己設計腳本來使用。
+ 用法：
	+ 使用 npm run [script name] 指令。
	+ 這邊的範例是使用　`npm run start` 來達成跟 `node JSpractice` 一樣的效果。
	+ 範例二：使用　`npm run tryEcho` 等於在終端機輸入 `echo 123`。
---
## NPM 版本號
打開 package.json 裡面的內容如下：
``` 
//...
"dendencies": {
   "accepts": "~1.3.7",
   "array-flatten": "1.1.1",
   "body-parser": "^1.19.0",
   // ...
 }
```
以 `"accepts": "~1.3.7",` 這行為例：
+ 1 代表主要版本號
+ 3 代表次要版本號
+ 7 代表修訂號 (bug)
+ `~` 波浪符號代表指定安裝為不超過**次要**版本號的版本 (指定為 >= 1.3.7 且 < 1.4.0 的版本)

以 `"body-parser": "^1.19.0",` 這行為例：
+ 1 代表主要版本號
+ 19 代表次要版本號
+ 0 代表修訂號 (bug)
+ `^` 符號代表指定安裝為不超過**主要**版本號的版本 (指定為 >= 1.19.0 且 < 2.0.0 的版本)

> 參考資料：[npm 維基百科](https://zh.wikipedia.org/wiki/Npm) & [NPM是什麼？了解Node Package Manager套件管理機制](https://tw.alphacamp.co/blog/npm-node-package-manager)

# 模組化與 Library
## 引用別人的模組
``` js
var module =require('os')
console.log(module.platform()) //win32
```

+ `require` 為引入的指令
+ `os` 為 Node.js 提供的 module

## 自己寫模組來用
### Step 1. 建立一個 JS 檔案 (這邊命名為 myModule.js)
``` js
//in myModule.js

function double(x) {
  return x * 2
}

module.exports = {
    double: double,
    triple: function(x){
        return x * 3
    }
}
```
### Step 2. 再建立一個 JS 檔案 (主要 JS 檔案，這邊命名為 main.js)
``` js
//in main.js

var myModule = require('./myModule.js')
console.log(myModule)
=> { double: [Function: double], triple: [Function: triple] }

console.log(myModule.double(2)) // output to be 4
console.log(myModule.triple(3)) // output to be 9
```
+ `var myModule = require('./myModule.js')`：引入的模組非 Node.js 提供或從 NPM 下載安裝，所以要自己輸入檔案路徑。
+ `module.exports`：輸出 module 的指令。

## 延伸題：另一種輸出指令 (exports.[keyName])
``` js
//in myModule.js
let arr1 = [1, 2, 3]

exports.arr1 = arr1
exports.arr2 = [4, 5, 6]

-------

//in main.js
var myModule = require('./myModule')
console.log(myModule) // output to be => { arr1: [ 1, 2, 3 ], arr2: [ 4, 5, 6 ] } 物件型態
```
+ `exports.[keyName]` 指令只能輸出成物件
+ `module.exports` 指令可輸出成字串或者陣列等其他型態 (雖然陣列也是物件的一種)，範例如下：

``` js
//in myModule.js
let arr1 = [1, 2, 3]
module.exports = arr1


-------

//in main.js
var myModule = require('./myModule')
console.log(myModule) // output to be => [1, 2, 3] 陣列型態
```
# ES6 (ES 2015)
## 新的宣告變數方式 const 與 let
+ ### const (constant variable)：宣告一個常數，其值不能再被變動
``` js
const PI = 3.14
PI = 20
console.log(a) // output to be => TypeError: Assignment to constant variable.
```
注意！以下情況例外：
``` js
const obj = {
  b: 10
}

obj.b = 20
console.log(b) // output to be 20

---

const arr = [1, 2, 3]
arr.push(4, 5)
console.log(arr) // output to be [1, 2, 3, 4, 5]
```
因為變數存取物件(陣列)的方式是存取記憶體位置，原則上此 obj 物件的記憶體位置(指引)沒有被更動，被更動的是指引指向的值。
這是一個比較抽象的概念，可以回顧一下這兩篇 [從 Object 的等號真正的理解變數](https://github.com/TsaiChihWei/learning-blog/issues/4)與[從博物館寄物櫃理解變數儲存模型](https://medium.com/@hulitw/variable-and-frontdesk-a53a0440af3c)。

---
## 作用域 scope (變數的生存範圍)
+ ### let 與 const 是區塊作用域 (block scope) `{} 包起來的區域`
+ ### var 是函式作用域 (function scope)
``` js
function test() {
    if (true) {
        var a = 10
    } 
    console.log(a);
}

test() // output to be 10
```
使用 `var` 宣告變數 a 時，可用範圍在 test function 內，即便 `console.log(a)` 在 if block 之外仍能讀取到 a 的值。
``` js
function test() {
    if (true) {
        let a = 10
    } 
    console.log(a)
}

test() // ReferenceError: a is not defined
```
使用 `let` 宣告變數 a 時，可用範圍在 if block (大括號) 內，所以 `console.log(a)` 在離開 if block 的區域便無法讀取到 a 的值。
``` js
function test() {
    if (true) {
        const a = 10
    } 
    console.log(a)
}

test() // ReferenceError: a is not defined
```
`const` 與 `let` 同理，都是區塊作用域 (block scope)。
### 因應 ES6 的出現，使用上建議不要再用 `var` 來宣告變數，改用 `let` 與 `const`，限縮變數的活動範圍來減少發生錯誤的可能。

## 模板字串 Template Literals
+ Template Literals 是增強版的字串表示法，Template Literals 讓你可以寫多行字串 (multi-line strings)、也可以在字串中插入變數或 JavaScript 表達式。
+ 用法：使用兩個反引號 (back-tick) ` ` 標示，而在字串中可以使用 `${ }` 語法來嵌入變數或 JavaScript 表達式。
### 多行字串 Multi-line Strings
``` js
//傳統寫法
let str = 'this is line one\n' + 'this is line two'
console.log(str); /* output to be =>

this is line one
this is line two 
*/
// 反斜線n \n 為換行


//Template Literals 寫法
let newStr = `
this is line one
this is line two`
console.log(newStr) /* output to be =>

this is line one
this is line two 
*/
```
### 嵌入變數或任何表達式
``` js
//傳統寫法
let name1 = 'Jack'
let age1 = 25
console.log('His name is ' + name1 + 'and he is ' + age1 + ' years old.')
// output to be => His name is Jack and he is 25 years old.


//Template Literals 寫法
let name2 = 'Ryan'
let age2 = 23
console.log(`His name is ${name2} and he is ${age2} years old.`)
// output to be => His name is Ryan and he is 23 years old.


//加入表達式
//${} 中可以是任何 JavaScript expression
function sayHello(name) {
    return `Hello ${name.toUpperCase()}!`
}
console.log(sayHello('Maggie')) //output to be => Hello MAGGIE!
```

## 解構賦值 Destructuring
解構賦值 ( Destructuring Assignment)是一個在 ES6 的新特性，目的用於提取陣列或物件中的資料**變成獨立變數**。
### 陣列解構賦值
+ 傳統寫法
``` js
let arr = [1, 2, 3, 4]
let first = arr[0]
let second = arr[1]
let third = arr[2]
let fourth = arr[3]

console.log(first, second, third, fourth) // 1 2 3 4
```
+ ES6 解構寫法
``` js
let arr = [1, 2, 3, 4]
let [first, second, third, fourth] = arr

console.log(first, second, third, fourth) // 1 2 3 4
```
### 其他案例
*註：陣列解構賦值會將右方的資料與左邊對應，一個位置對應一個值。*

+ 情況一：當變數多於所給的值
``` js
let [a , b, c, d] = [1, 2, 3]
console.log(a, b, c, d) // 1 2 3 undefined
```
+ 情況二：當變數少於所給的值
``` js
let [a , b, c] = [1, 2, 3, 4]
console.log(a, b, c) // 1 2 3 
```
+ 情況三：若遇到空的變數，這些值將被跳過
``` js
let [a, , b, c] = [1, 2, 3, 4]
console.log(a, b, c) // 1 3 4 

let [x, , ,y, z] = [5, 6, 7, 8]
console.log(x, y, z) // 5 8 undefined 
```
+ 情況四：字串拆解
``` js
let str = 'Ryan'
let [a, b, c, d] = str

console.log(a, c) // R a
```
+ 情況五：交換變數
``` js
let apple = 'red'
let lemon = 'green'
;[apple, lemon] = [lemon, apple]
console.log(apple, lemon)
```
> ### 防雷須知 *此內容引用至 [@PJCHENder](https://pjchender.blogspot.com/2017/01/es6-array-destructuring.html)*
> 如果你使用的是 [standard JS](https://standardjs.com/readme-zhtw.html) 當作你的 code style，那麼你應該很習慣在結尾不加分號，但是在使用陣列的結構賦值時，這麼做**有可能**會發生錯誤。例如：
``` js
let apple = 'red'
let lemon = 'green'
[apple, lemon] = [lemon, apple]
console.log(apple, lemon)
```
> 這邊會得到 `ReferenceError: lemon is not defined` 的錯誤。首先簡單說明一下之所以可以不用在結尾加分號是因為在**多數情況**下，在語句或一段代碼敘述後，加了 Enter 鍵(\n)後，JS剖析器會在執行期間自動幫你插入分號。上面提到是多數情況，但是在**某些情況下** JS 引擎是不會幫你加上分號的，其中像是這裡的開頭以 `[` 開頭的語句。因此在這裡，請記得在 [ 的前面加上分號，寫起來會像是這樣 `;[apple, lemon] = [lemon, apple]`，才能避免錯誤產生。

### 物件解構賦值
物件的解構賦值強調的是`屬性名稱`，屬性名稱必須與變數名稱相互對應才能取到值，反之則會無法取值。
+ 傳統寫法
``` js
let person = {
    gender: 'male',
    firstName: 'Leonardo',
    lastName: 'Dicaprio'
}

let gender = person.gender
let firstName = person.firstName
let lastName = person.lastName
console.log(gender) // male
console.log(firstName) // Leonardo
console.log(lastName) // Dicaprio
```
+ ES6 解構寫法
``` js
let person = {
    gender: 'male',
    firstName: 'Leonardo',
    lastName: 'Dicaprio'
}

//一次宣告三個變數
let {gender, firstName, lastName} = person
console.log(gender) // male
console.log(firstName) // Leonardo
console.log(lastName) // Dicaprio
```
### 其他案例
+ 情況一：變數名稱對應不到物件中的屬性名稱時，則會出現 undefined
``` js
let person = {
    gender: 'male',
    firstName: 'Leonardo',
    lastName: 'Dicaprio'
}

let {gender, first, last} = person
console.log(gender) //male
console.log(first) //undefined
console.log(last) //undefined
```
+ 情況二：將變數名稱重新命名 (不想以屬性名稱當作變數的時候)
``` js
let person = {
    gender: 'male',
    firstName: 'Leonardo',
    lastName: 'Dicaprio'
}

let {gender, firstName: first, lastName: last} = person
console.log(gender) //male
console.log(first) //Leonardo
console.log(last) //Dicaprio
```
使用冒號 `:` 後面接新的變數名稱
+ 情況三：解構再解構
``` js
let person = {
    gender: 'male',
    name: {
        firstName: 'Leonardo',
        lastName: 'Dicaprio'
    }
}

let {name} = person
console.log(name) //{ firstName: 'Leonardo', lastName: 'Dicaprio' }

let {name: {firstName, lastName}} = person
console.log(firstName) //Leonardo
console.log(lastName) //Dicaprio
```
冒號 `:` 後面再使用大括號即再解構一次
+ 情況四：解構再解構再加上重新命名變數名稱
``` js
let person = {
    gender: 'male',
    name: {
        firstName: 'Leonardo',
        lastName: 'Dicaprio'
    }
}
let {name: {firstName: one, lastName: two}} = person
console.log(one) //Leonardo
console.log(two) //Dicaprio
```
+ 解構也能使用在函式的參數，使用方式如同將傳入的物件對應到函式參數上。這樣參數一樣能夠能夠自訂變數名稱、順序、預設值等
``` js
function test({a, b}) {
    console.log(a, b)
}

test({
    a: 1,
    b: 2
})
// output to be 1 2

/* 原本的寫法為:
function test(obj) {
    console.log(obj.a, obj.b);
}

test({
    a: 1,
    b: 2
})
*/
```